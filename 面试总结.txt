Java虚拟机

Java虚拟机内存分布，对象访问定位（句柄访问（对象数据，类型数据），直接指针）Gc roots(栈帧，静态，常量，native)

垃圾回收算法：标记清除（标记回收），复制，标记整理，分代收集（新生：复制，老年：标记整理）

CMS收集器：（标记清除）（初始标记-并发标记-重新标记-并发清除）系统停顿短

内存回收：对象在新生代分配，大对象进入老年代，长期存活对象进入老年代，动态对象年龄判断，空间担保

类加载：（加载-验证-准备（类变量）-解析（运行时动态绑定）（类接口解析，字段解析，类方法）-初始化（构造函数）-使用-卸载）（解析对象可能发生在初始化之后，这是为了支持java的运行时动态绑定）

类加载是有那些来源：ZIP中读取，网络，运行计算生成，数据库读取

类加载机制：双亲委托模型，自定义：继承findClass(),重写loadClass会破坏双亲委托模型
（没有双亲委托模型，类加载器自己自行加载，我们编写java.lang.Object，放在classpath下，系统中就会出现多个Object类，造成系统混乱）


Java多线程-----------------------------------------------------------------

	Java内存模型：屏蔽掉各种硬件我硬件操作系统之间的差异，使得Java程序可以在各种平台下达到一致效果

	内存模主要目标是定义程序中各个变量的访问规则（主内存，工作内存，线程）

	Java内存模型是围绕着并发过程中是如何处理原子性，可见性，顺序性3个特征来建立的

	happens_beforec:程序次序规则（按程序代码顺序，前面的HB后面的；管程锁定：unlock HB lock;volatile：写HB读；传递性）

	线程状态:新建，运行，无限期等待，限期等待，阻塞，结束

	9、Java内存模型里面为什么要分主存和本地内存



Spring--------------------------------------------------------------------

IoC(Inversion of Control)思想：对象之间的依赖关系交给来ioc容器管理

IOC容器：实际上是一系列功能各异的容器产品，通过HashMap持有BeanDifinition

	BeanFactory容器的核心接口，BeanDefinition 是对象抽象，默认容器DefaultListTableBeanFactory,XMLBeanFactory-->
		XmlBeanDefinitionReeader进行处理-->解析规则在BeanDifinitionParserGate中定义
			资源加载器：Resource-->ClassPathResource--->FileSystemResource

	1、IOC容器初始化：调用refresh()方法启动：BeanDifinition的定位:xml文件 载入:读取xml文件 和注册：将BeanDifinition注入到HashMap中
	2、BeanFactory和FactoryBean的区别：BeanFactory其实是定义了容器的规范，他本身是一个容器(HashMap);BeanFactory是一个可以生产和修饰对象的Bean，通过&才能拉到对象FactoryBean本身
	3、容器通过getBean方法返回的不是FactoryBean本身，而是FactoryBean实现类中getObject()方法所返回的对象(http://www.cnblogs.com/chenying99/archive/2012/09/23/2698878.html)

AOP(Aspect Oriented Programming)：面向切面编程。她其实是对面向对象编程的一种补充，比如一个系统使用oop的编程思想，当系统规模变大以后，
				有些问题oop就很难解决，比如添加日志这种，如果通过代码复制就会出现很多问题。这时就体现了OOP编程的优越性

				主要运用了jdk动态代理中的Proxy类和InvicationHandler接口实现，但是目标类一定要实现一个接口，
				如果没有实现接口，spring就会用cglib包实现AOP。推荐的还是要实现一个接口

AOP一般都是通过代理来实现,利用代理就有目标对象是什么,拦截哪些点(方法),拦截后要做什么。

JoinPoint(连接点)：被拦截到的点. Advice(通知):拦截JoinPoint之前与之后要做的事。

PointCut(切入点):对joinPoint进行拦截的定义。Target(目标对象)：代理的目标对象。
切面：
增强：

对于异常处理,日志功能,权限的检查,事务等都是贯穿到各个模块之中,因此进行AOP.



代理模式，可以分为两种，一种是静态代理，一种是动态代理。



一、springMVC工作原理： 
	1.spring mvc请所有的请求都提交给DispatcherServlet。
	2.DispatcherServlet请求HandlerMapping,查找到handler(xml配置)
	4.前端控制器调用处理器适配器执行handler,并返回ModelAndView
	5.处理器适配器返回modelAndView
	6.Dispathcher查找ViewResolver视图解析器,找到ModelAndView对象指定的视图对象
	7.视图对象负责渲染返回给客户端。 

Mysql---------------------------------------------------------------------

SQL语句：select
	from
	where
	group by
	having
	order by

三大范式：
	1、数据库表的每一列都是不可分割的基本数据项：姓名学号	学院专业	双亲姓名
	2、完全依赖于主键：学号	姓名	课程	学分	成绩（数据冗余，更新异常，删除异常）
	3、属性不依赖于其它非主属性[消除传递依赖]：学号	所在学院	学院地点	学院电话

Mysql事务特性(ACID)
	1、原子性（Atomicity）：事务操作原子性
	2、一致性（Consistency）：并发一致，（转账问题）
	3、隔离性（Isolation）：（事务之间不影响）
	4、持久性（Durability）（持久化到数据库）

Mysql事务隔离级别：
	1、Read Uncommitted：可能读取到未提交事务修改的数据（导致脏读）
	2、Read Committed：只能读取到已经提交的数据（导致不可重复读）
	3、Repeatable Read：同一个事务内查询是一致的（导致幻读）（Mysql默认级别，采用MVCC解决幻读）
	4、Serializable：读写相互都会阻塞（锁竞争和超时现象）

MVCC解决幻读（多版本并发控制）：MVCC允许数据具有多个版本，innodb会为每一行添加两个字段，分别表示该行创建的版本和删除的版本
	select：满足以下两个条件innodb会返回该行数据：
		（1）该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。
		（2）该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。
	insert：将新插入的行的创建版本号设置为当前系统的版本号。
	delete：将要删除的行的删除版本号设置为当前系统的版本号。
	update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。

Mysql引擎的选择：
	有外键或者需要支持事务：InnoDB
	数据的大小：InnoDB支持事务和故障恢复，InnoDB可以利用事务日志进行数据恢复
	数据库的操作习惯：COUNT（）和大批Insert使用MyISAM比较好，InniDB使用索引进行查询会比较快

MyISAM与InnoDB的区别：
		MyISAM		InnoDB
	 存储	数据索引分离	索引文件就是数据文件
	 事务	不支持事务	支持事务
	 外键	不支持外键	支持外键
	   锁	支持表锁	支持行锁
     全文索引	支持全文索引	不支持全文索引
count和insert	更快		不行
select和update	不行		更快
总的来说：InnoDB的设计目标是处理大容量数据库系统，它的数据库利用率是基于磁盘的关系数据库不能比的

SQL优化问题
	1、开启Mysql服务器的查询缓存
	2、只用一行数据是用limit
	3、为搜索建立索引
	4、避免使用select*
	5、为每张表设计一个ID
	6、尽量使用NOT NULL
	7、拆分大的DELETE和INSERT/避免大事务
	8、每个字段尽量小
	9、选择正确的数据库引擎
	10、垂直分割：是一张表变成几张表
	11、Explain 检测select查询语句

索引优化：
	1、最左前缀匹配原理
	2、索引失效
		1、中间索引不存在无法与左前缀链接
		2、查询是没有制定第一列
		3、通配符%不出现在开头，则可以用到索引
		4、范围查询
		5、查询条件中含有函数或表达式
	3、索引选择性与前缀索引
		索引选择性：列的不重复值/表记录
		前缀索引：用列的前缀代替整个列作为索引key
	4、InnoDB主键的选择
		1、主键选择：与业务无关的自增主键（InnoDB使用聚集索引，如果主键是自增的，那么记录就按顺序存放；如果使用非自增主键：为了将记录插在合适的位置会增加IO读写）

Explain的使用及优化（rows是核心指标）
	1、注意Extra列：如果是useing filesort 或者
	2、看有没有使用到预期的索引，扫描的rows是不是很多，如果是很多，说明索引不好，我们可能要修改索引


B+Tree:
	1、先找的节点，在有序表中查找，如果找到就返回，如果没有找到就在对应指针指向的子树去找，直到叶子结点
	2、Mysql使用的B+Tree的每个节点大小等于操作系统页的大小，这样减少了IO的次数
	3、索引文件文件比较大，所以以文件的形式保存着磁盘中，所以索引查找过程中，就会有磁盘的IO，磁盘IO速度缓慢，所以为了减少磁盘IO次数，
	操作系统就会采取局部于预读的方式，而数据库就是利用了局部预读的原理，将节点大小设置为一个页的大小


网络协议问题---------------------------------------------------------
	
	1、TCP和UDP的区别：TCP是面向有链接的，在通信前建立链接，提供IP环境下数据的可靠传输；UDP是面向无连接的，不提供可靠，流控，容错恢复等功能
	2、三次握手：客户端发送SYN报文，等待响应，服务器确认报文，发送自己的ACK（SYN）报文，客户端收到确认消息，自己再发送确认报文给服务器（报文中没有数据）
	3、为什么是三次握手：服务器发送报文以后不能确认客户端一定收到，所以需要客户端发送确认报文
	4、四次挥手：客户端发送FIN报文，表示没有数据了，服务器发送ACK报文，服务器发送FIN报文，进入TIME_WAIT状态，客户端收到FIN报文发送ACK报文
	5、大端序：数据的高字节存储在内存的底地址，数据的低字节存高地址
	6、小端序：底地址存储数据的低字节，高地址存储数据的高字节
	7、序列号：将数据看作是一个字节流，序列号就是字节流的编号；TCP每次传送的报文段中的序号字段值表示所要传送本报文中的第一个字节的序号
	8、TCP的报文到达确认（ACK）中的序号字段：下次接收时期望的TCP数据包的序列号
	9、TCP的功能：检验和，序列号，确认应答，重发控制，链接管理，窗口控制
	10、窗口控制
	
		
memcached工作原理---------------------------------------------------
	1、memcached集群有两个核心组件：（存取两步）1、找服务器；2、存取数据
		服务端和客户端：在客服端保持着一个服务端的一个链表，当客户端set k-v的时候，对key进行hash运算，根据hash确定服务器，连接上服务器以后，将K-V保存在服务器
		当取得时候通过对key进行hash运算，根据hash值确定服务器，然后取值。
	2、内存分配：memcached有一个“块分配器”的组件来分配内存.将内存分成不同大小的块，数据存放时更具数据大小，选择匹配内存块（避免内存浪费，而且操作系统会消耗大量的时间来寻找连续的内存空间）
	3、缓存策略：当memcached服务器用完分配的内时，会使用新插入的数据来代替老的数据。（LRU）（最近最少使用）（也可以知道数据的失效时间）
	4、分布式算法：
		1、余数法：简单高效，但是增加减少服务器会缓存失效；
		2、散列法：算出memcached服务器的散列值，并将其分布到0到2的32次方的圆上，然后用同样的方法算出存储数据的键的散列值并映射至圆上，从数据映射到的位置开始顺时针查找


NIO原理-----------------------------------------------------------
	1、BIO：面向流，在面向流的 I/O 中，您将数据直接写入或者将数据直接读到 Stream 对象中，系统只能一个字节一个字节的访问
	2、NIO面向缓冲区：将数据直接写入或者将数据直接读到 Stream 对象中
	3、通道时双向的，流是单向的。在通道上可以注册我们感兴趣的事件

	4、selector：事件驱动机制：事件到的时候触发，而不是同步的去监视事件
	5、selector：Selector内部原理实际是在做一个对所注册的channel的轮询访问。
	

ConcurrentHashMap----------------------------------------------
	实现思想：分离锁实现线程的并发，
		HashEntry对象的不变性来降低读对锁的要求：hashEntry的key,hash,next指针都是final类型的，保证了不能在链表的中间插入，删除，这样保证在访问某个节点的时候，节点后的链表不好发生改变
		Volatile变量的内存可见性：写线程写入的值，能够被之后未加锁的读线程“看到
	
	结构分析：静态内部类：HashEntry:保存了映射表的键值对，Segmment:充当锁的角色，每个Segment里面封装了一个HashEntry的数组，数组的每个元素都相当于链表的头节点
		Segment：继承ReentrantLock


什么事反射机制：在运行的时候可以知道类的信息

Integer自动装箱-------------------------------------------------

//由于没有了装箱，以下两条语句创建了2个对象。两个1对象存储在堆内存中 
    Integer l1 = new Integer(1); 
    Integer k1 = new Integer(1); 
    System.out.println(l1==k1);//false 
　　//以下两条语句创建了1个对象。1对象存储在栈内存中。自动装箱时对于值从127之间的值，使用一个实例。
    Integer l = 20;//装箱 
    Integer k = 20;//装箱 
    System.out.println(l==k);//true 
//以下两条语句创建了2个对象。i1,i2变量存储在栈内存中，两个256对象存储在堆内存中 
    Integer i1 = 256; 
    Integer i2 = 256; 
    System.out.println(i1==i2);//false 



多线程模块--------------------------------------------------------------

1、Java中有两种实现多线程的方式以及两种方式之间的区别
	1、继承Thread
	2、实现Runnable接口
	3、使用集合框架
实现Runnable的原因：线程的启动和任务分离，较好地体现了面向对象的设计思想。 
	2、避免但继承带来的局限性
2、sychronized和ReentreantLock的区别：公平锁，多个Condition对象

3、在使用Object.wait()使当前线程进入该Object的阻塞队列时，以及用Object.notify()或Object.notifyAll()唤醒该Object的阻塞队列中一个或所有线程时，
	必须在外层使用synchronized (Object)，这是JAVA中线程同步的最常见做法。之所以在这里要强制使用synchronized代码块，是因为在JAVA语义中，
	wait有出让Object锁的语义，要想出让锁，前提是要先获得锁，所以要先用synchronized获得锁之后才能调用wait，notify原因类似。
	而Object.wait()和notify()不具有原子性语义，所以必须用synchronized保证线程安全

4、使用synchronized时有三个原则：
	1、sychronized的对象最好选择引用不会变化的对象
	2、尽可能把synchronized范围缩小，线程互斥是以牺牲并发度为代价的，这点大家都懂
	3、尽量不要在可变引用上wait()和notify()



序列化问题-------------------------------------------------------------
	
	1、序列化的对象继承Serializable接口，通过ObjectOutputStream/ObjectInputStrean序列化和烦序列化
	2、serialVersionUID的创建
	3、序列化在序列化对象中重写writeObject和readObject方法，序/反序进行控制（ObjectOutputStream反射调用该方法）
	4、Externalizable接口：writeExternal()与readExternal()方法
	5、为了能在序列化过程仍能保持单例的特性，可以在Person类中添加一个readResolve()方法，在该方法中直接返回Person的单例对象
	6、与ReentrantLock（JDK1.5之后提供的锁对象）一类的锁相比有什么优劣？

	ReentrantLock代表了JDK1.5之后由JAVA语言实现的一系列锁的工具类，而synchronized作为JAVA中的关键字，是由native（根据平台有所不同，
	一般是C）语言实现的。ReentrantLock虽然也实现了 synchronized中的几种锁优化技术，但与synchronized相比，性能未必好，

	毕竟JAVA语言效率和native语言效率比大多数情况总有不如。ReentrantLock的优势在于为程序员提供了更多的选择和更好地扩展性，比如公平性锁和非公平性锁，读写锁，CountLatch等。

	细心地人会发现，JDK1.6中的并发容器大多数都是用ReentrantLock一类的锁对象实现。例如LinkedBlockingQueue这样的生产者消费者队列，虽然也可以用synchronized实现，

	但是这种队列中存在若干个互斥和同步逻辑，用synchronized容易使逻辑变得混乱，难以阅读和维护。

	总结一点，在业务并发简单清晰的情况下推荐synchronized，在业务逻辑并发复杂，或对使用锁的扩展性要求较高时，推荐使用ReentrantLock这类锁。

设计模式：

1、装饰者模式：（举例）它主要采用组合的方式来取代继承，让功能扩展更加灵活。
	Java中的IO流设计：使用装饰者模式：要在InputStream外面套上一层InputStreamReader,再套上一层BufferedReader。
	InputStream是一种字节流，读进来都是一个个字节，套上一层InputSteamReader就可以转换成字符流，读进来是一个个字符。
	再套上一层BufferedReader, BufferedReader有一个readLine方法，可以一次性读取文件中的一行数据，可以一行行读
	只要读取不为空，就可以把读到的数据添加到StringBuffer中去，知道读到一个空行，跳出。

2、模板方法模式：统一子类实现的步骤，在父类中定义一系列抽象的方法，在子类中一一实现这些方法
	类加载器：ClassLoader类就使用了模板模式，去保证类加载过程中的唯一性；ClassLoader实现了loadClass()方法，但是findClass()方法和交个子类来实现
	和AQS框架：该类实现了setState（），compareAndSetState（）方法，，但是tryAcquire（）和tryRelease（）这些方法交个子类来实现。

3、抽象工厂模式：



项目问题----------------------------------------------------------------
项目介绍：
	两类用户，算法工程师需要测试算法的性能和正确性，上传到我们的平台，我我们进行运算，将结果以可视化的方式展现给用户
	企业用户，企业有数据进行处理，没有算法工程师，上传数据，选择我们平台提供的算法进行运算，我们会将运算结果反馈给用户

个人任务：
	项目分为3大模块：
	运行环境：算法加载，数据集构造，异常处理，算法状态监控（观察者模式），远程调用（HttpUrlConnection,xml协议）
	运行环境：用户模型序列化（序列化），模型的使用
	可视化：。。。。。。



